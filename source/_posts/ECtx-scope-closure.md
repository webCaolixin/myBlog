---
title: 从JS运行机制彻底理解执行环境、作用域、作用域链、闭包
date: 2019-03-13 14:30:37
categories: 编程
tags: JavaScript
---

> JavaScript中的执行环境、作用域、作用域链、闭包一直是一个非常有意思的话题，很多博主和大神都分享过相关的文章。这些知识点不仅比较抽象，不易理解，更重要的是与这些知识点相关的问题在面试中高频出现。之前我也看过不少文章，依旧是似懂非懂，模模糊糊。最近，仔细捋了捋相关问题的思路，对这些问题的理解清晰深入了不少，在这里和大家分享。

这篇文章，我会按照执行环境、作用域、作用域链、闭包的顺序，结合着JS中函数的运行机制来梳理相关知识。因为这样的顺序刚好也是这些知识点相互关联且递进的顺序，同时这些知识点都又与函数有着千丝万缕的联系。这样讲解，会更容易让大家彻底理解，至少我就是这样理解清晰的。

废话不再多说，我们开始。

### 执行环境

首先，我们还是要理解一下什么是执行环境，这也是理清后面问题的基础。

> 执行环境是JavaScript中最为重要的一个概念。执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。——《JavaScript高级程序设计》

抽象！不理解！没关系，我来解释：其实，执行环境就是JS中提出的一个概念，它是为了保证代码合理运行采用的一种机制。

一种概念...机制...更抽象，那它到底是什么？**实际上，执行环境在JS机制内部`就是用一个对象来表示的`，称作`执行环境对象`**。

那么，这个执行环境对象到底又是何时、怎么产生的呢？有以下两种情况：

1. 在页面中的脚本开始执行时，就会产生一个“全局执行环境”。它是最外围（范围最大，或者说层级最高）的一个执行环境，对应着一个全局执行环境对象。在Web浏览器中，这个对象就是`Window`对象。
2. 当一个函数被调用的时候，也会创建一个属于该函数的执行环境，称作“局部执行环境”（或者称作函数执行环境），它也对应着自己的执行环境对象。

因此，执行环境就分为`全局执行环境`和`局部执行环境`两种，每个执行环境都有一个属于自己的执行环境对象。

既然执行环境是使用一个对象表示的，那么对象就有属性。我们来看看执行环境对象的三个有意思的属性。`变量对象`、`[[scope]]`、`this`。

![执行环境对象][2]

#### 执行环境对象中的变量对象

《JS高程》中明确说明，执行环境定义了变量或函数有权访问的其他数据。那么这些数据到底被放（存储）在哪里呢？

其实，每个执行环境都有一个与之关联的变量对象，在环境中定义的所有变量和函数都保存在这个对象中。我们在代码无法访问这个对象，但解析器在处理数据时会在内部使用它。

通俗地说就是：一个执行环境中的所有变量和函数都保存在该执行环境对象的变量对象（属性）中。

#### 先理解作用域

在讲`[[scope]]`前，我们就需要先弄清楚什么是**作用域**了。因为作用域与`[[scope]]`之间存在着非常紧密的关系。

>《JS高程》中没有明确给出作用域的定义和描述。其实，作用域就是变量或者函数可以被访问的代码范围，或者说作用域就是变量和函数所起作用的范围。

这样看来作用域也像是一个概念，它是用来描述一个区域（或者说范围）的。在JS中，作用域分为`全局作用域`、`局部作用域`两种。

我们来看看这两种作用域的具体描述：

1. 在页面中的脚本开始执行时，就会产生一个“全局作用域”。它是最外围（范围最大，或者说层级最高）的一个作用域。全局作用域的变量、函数
可以在代码的任何地方访问到。
2. 当一个函数被创建的时候，会创建一个“局部作用域”。局部作用域中的函数、变量只能在某些局部代码中可以访问到。

看一个例子：
```
var g = 'Global';

function outer() {
  var out = 'outer';

  function inner() {
    var inn = 'inner';
  }
} 
```

上面这个例子，产生的作用域就如下图所示：

![作用域][1]

**请注意上面1./2.这两段话！！！**是不是觉得很熟悉，似曾相识？！没错，这两段话和介绍全局/局部执行环境（全局/局部执行环境对象）时候的描述几乎一摸一样！作用域是不是和执行环境对象有着千丝万缕的联系呢？与此同时，我们再仔细回忆一下：**①**作用域就是变量或者函数可以被访问的代码范围。**②**一个执行环境中定义的所有变量和函数都保存在它对应的执行环境对象中。

结合上面所述，其实不难得出：尽管作用域的描述更像是一个概念，但如果一定要将它具象化，问它到底是什么东西，与执行环境有什么关系？**`其实，作用域所对应的（不是相等、等于）是执行环境对象中的变量对象。`**

明白了这些，我们就可以来看看执行环境对象中的[[scope]]属性。

#### 执行环境对象中的[[scope]]

首先，要明确的是，执行环境对象中的[[scope]]属性值是一个指针，它指向该执行环境的作用域链。

到底什么是作用域链呢？**作用域链本质上就是一个`有序的列表`，而列表中的每一项都是一个`指向执行环境对象中的变量对象的指针`。**

那么，这个作用域链到底是怎么形成的呢？它里面指向变量对象的指针的顺序又是如何让规定的呢？我们用下面这个简单的例子说明。

```
var g = 'Hello';

function inner() {
  var inn = 'Inner';
  var res = g + inn;
  return res;
}

inner();
```

当执行了`inner();`这一行代码后，代码执行流进入`inner`函数内部，此时，JS内部会先创建`inner`函数的局部执行环境，然后创建该环境的作用域链。这个作用域链的最前端，就是`inner`执行环境自己的执行环境对象中的`变量对象`，作用域链第二项，就是全局环境的环境对象中的`变量对象`。如下图所示：

![作用域链][3]

形成了这样的作用域链之后，就可以有秩序地访问一个变量了。以这个例子为例：当执行`inner();`进入函数体内后，执行`g + inn;`一行，需要访问变量`g、inn`，此时JS内部机制就会沿着这条作用域链查找所需变量。在当前`inner`函数的作用域中找到了变量`inn`，值为`'Inner'`，查找终止。但是却没有找到变量`g`，于是沿着作用域链向上查找，进入全局作用域，在全局变量对象中找到了变量`g`，值为`'Hello'`，查找终止。计算得出`res`为`'HelloInner'`，并在最后返回结果。

与上面所讲机制完全相同，如果是多层执行环境嵌套，则作用域链是这么形成的：

> 当代码执行进入一个执行环境时，JS内部会开始创建该环境的作用域链。作用域链的**最前端**，始终都是**当前执行环境的执行环境对象中的变量对象**。如果这个环境是**局部执行环境（函数执行环境）**，则将其**活动对象**作为**变量对象**。作用域链中的下一个是来自**外层环境对象的变量对象**，而再下一个则是来自**再外层环境对象的变量对象**...... 这样**一直延续到全局执行环境对象的变量对象**。所以，全局执行环境的变量对象始终都是作用域链中的最后一个对象。



[1]: /medias/article/coding/ectx-scope-closure/scope.jpg
[2]: /medias/article/coding/ectx-scope-closure/context-object.jpg
[3]: /medias/article/coding/ectx-scope-closure/scope-chain.jpg